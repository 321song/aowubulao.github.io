<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Ssl pinning下的安卓免root抓包</title>
    <link href="/posts/andriod-noroot-cap/"/>
    <url>/posts/andriod-noroot-cap/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在研究安卓的App如何抓包，一开始想的很简单，以为就和浏览器F12里那样简单，所以直接搜了一个号称免root抓包的App到手机上。打开后发现应用都不能联网了。以为是软件的问题，遂百度了一番，开始用fiddler4抓包——结果还是，应用都没有网了。</p><h2 id="Ssl-Pinning"><a href="#Ssl-Pinning" class="headerlink" title="Ssl Pinning"></a>Ssl Pinning</h2><p>然后又是一阵的搜索，发现是Ssl Pinning搞的鬼，如果熟悉https的话，应该知道CA证书吧，用于检验请求双方的身份，防止中间人攻击。在抓包的时候，通常会在手机中设置一个代理，安装代理的证书，但这个证书是不被应用信任的，通过代理时，应用就不会发出请求，从而导致了没有网络的情况。</p><h2 id="Virtual-Xposed"><a href="#Virtual-Xposed" class="headerlink" title="Virtual Xposed"></a>Virtual Xposed</h2><p>现在问题的关键在于如何绕开Ssl Pinning的干扰，一个成熟的办法是手机root安装xposed模块+just trust me，可以在不被信任的情况下强制绕过，发出请求。</p><p>不过现在手机root都很麻烦，我试了一下用安装模拟器运行应用，但是很多应该在模拟器上都不能很好的运行甚至闪退。</p><p>这时候我发现了<a href="https://vxposed.com/" target="_blank" rel="noopener">Virtual Xposed</a>这个神器。一个虚拟的沙箱，自带一个root环境+xposed框架，软件也是轻量级的。</p><p>最后使用的模块是virtual xposed + trust me already，同时将要抓包的应用导入vx当中，运行，外部再使用Fiddler4抓包就ok了。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安卓</tag>
      
      <tag>抓包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java线程池的创建方法</title>
    <link href="/posts/java-threadpool/"/>
    <url>/posts/java-threadpool/</url>
    
    <content type="html"><![CDATA[<h2 id="1、自动创建（不推荐）"><a href="#1、自动创建（不推荐）" class="headerlink" title="1、自动创建（不推荐）"></a>1、自动创建（不推荐）</h2><p>在Java8以后，线程池的创建方法有5种，这里介绍3种常用的方法。</p><pre><code class="hljs java">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);ExecutorService threadPool = Executors.newSingleThreadExecutor();ExecutorService threadPool = Executors.newCachedThreadPool();</code></pre><p>第一种是创建一个定容的线程池；</p><p>第二种是创建一个只有一个线程容量的线程池；</p><p>第三种是创建一个带缓存可扩容的线程池。</p><p>但是在使用时，阿里的代码检测工具会提示手动建立线程池。看一下源码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                      <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService            (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());&#125;</code></pre><p>三种方法底层其实都是使用了new ThreadPoolExecutor的方式创建线程池，第三种的最大线程容量甚至达到了Integer.MAX_VALUE，如果允许线程池无限扩容的话，会创建非常多的线程。而前两种的主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</p><p>所以如何手动创建线程池是我们需要学习的。</p><h2 id="手动创建线程池"><a href="#手动创建线程池" class="headerlink" title="手动创建线程池"></a>手动创建线程池</h2><p>我们可以通过new ThreadPoolExecutor的方式手动创建线程池，首先我们要了解构造方法的七个参数的具体含义。</p><p>直接看代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> corePoolSize,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">long</span> keepAliveTime,</span></span><span class="hljs-function"><span class="hljs-params">    TimeUnit unit,</span></span><span class="hljs-function"><span class="hljs-params">    BlockingQueue&lt;Runnable&gt; workQueue,</span></span><span class="hljs-function"><span class="hljs-params">    ThreadFactory threadFactory,</span></span><span class="hljs-function"><span class="hljs-params">    RejectedExecutionHandler handler)</span></span></code></pre><p>corePoolSize：线程池中的常驻核心数线程；</p><p>maximumPoolSize：线程池能够容纳的同时执行的最大线程数；</p><p>keepAliveTime：多余的线程的存活时间；</p><p>unit：对keepAliveTime 的时间单位；</p><p>workQueue：任务队列，被提交但尚未被执行的任务；</p><p>threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程；</p><p>handler：拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数。</p><pre><code class="hljs java">ExecutorService threadPool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>,            <span class="hljs-number">5</span>,            <span class="hljs-number">1L</span>,            TimeUnit.SECONDS,            <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">3</span>),            Executors.defaultThreadFactory(),            <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy());</code></pre><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>定义：等待队列也已经排满了，再也塞不下新的任务了同时，线程池的max也到达了，无法接续为新任务服务这时我们需要拒绝策略机制合理的处理这个问题。</p><p>JDK内置的拒绝策略：</p><ul><li><p>AbortPolicy(默认): 直接抛出RejectedException异常，阻止系统正常运行；</p></li><li><p>CallerRunPolicy:  不会抛异常，也不会抛弃任务，而是会将某些任务回退到调用它的线程。</p><p>如：main调用了thread-pool-0计算1+1，而此时线程池已满，启动拒绝策略，会将这个任务返还给main线程，让main线程执行计算；</p></li><li><p>DiscardOldestPolicy: 抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交；</p></li><li><p>DiscardPolicy: 直接抛弃任务，不予任何处理，也不抛出异常。如果允许任务丢失，这是最好的方法。</p></li></ul><h3 id="合理配置线程池的容量"><a href="#合理配置线程池的容量" class="headerlink" title="合理配置线程池的容量"></a>合理配置线程池的容量</h3><p>如何合理配置线程池？</p><h4 id="CPU密集型"><a href="#CPU密集型" class="headerlink" title="CPU密集型"></a>CPU密集型</h4><p>CPU密集的意思是该任务需要大量的计算，而没有阻塞，CPU一直进行计算；</p><p>一般公式：CPU核数+1个线程的线程池。</p><h4 id="I-O密集型"><a href="#I-O密集型" class="headerlink" title="I/O密集型"></a>I/O密集型</h4><p>IO密集型不需要大量计算，而需要进行大量IO操作阻塞。</p><p>IO密集型，大多线程都会阻塞，所以需要尽可能多的线程：</p><ul><li>CPU核数 / (1 - 阻塞系数) 阻塞系数在0.8-0.9之间</li><li>CPU核数 * 2</li></ul><p>两种公式视场合使用。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java由volatile深入的一些问题</title>
    <link href="/posts/volatile/"/>
    <url>/posts/volatile/</url>
    
    <content type="html"><![CDATA[<h2 id="JMM-Java-Memety-Model-Java内存模型"><a href="#JMM-Java-Memety-Model-Java内存模型" class="headerlink" title="JMM(Java Memety Model) Java内存模型"></a>JMM(Java Memety Model) Java内存模型</h2><p>首先了解一下JMM，JMM本身是一种抽象的概念，描述的是一组规范。</p><h5 id="JMM关于同步的规范"><a href="#JMM关于同步的规范" class="headerlink" title="JMM关于同步的规范"></a>JMM关于同步的规范</h5><ol><li>线程解锁前，必须把共享变量的值刷新回主线程；</li><li>线程加锁前，必须把主内存的最新值读取到自己的工作内存；</li><li>加锁解锁是同一把锁。</li></ol><h5 id="JMM要求"><a href="#JMM要求" class="headerlink" title="JMM要求"></a>JMM要求</h5><ol><li>可见性</li><li>原子性</li><li>有序性</li></ol><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>有序性是指在单线程环境中, 程序是按序依次执行的。而在多线程环境中, 程序的执行可能因为指令重排而出现乱序。</p><p><strong>知识点：</strong></p><ul><li>内存可见性</li><li>主存与线程之间内存的联系</li></ul><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>volatile是java提供的轻量级的同步机制。</p><ul><li>保证可见性</li><li>不保证原子性</li><li>禁止指令重排</li></ul><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>原子性就是说一个操作不可以被CPU中途暂停然后调度，即不能被中断，要不就执行完， 要不就不执行。 如果一个操作是原子性的，那么在多线程环境下，就不会出现变量被修改等奇怪的问题。</p><h5 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h5><p>volatile实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象。保证多线程间的语义一致性。</p><p>实现方法：使用CPU内存屏障（Memery Barrier），在指令中插入一条Memery Barrier指令，会告诉编译器和CPU，禁止重排。</p><p>也就是说，通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。</p><p>内存屏障的另一个作用就是强制刷新各种CPU的缓存数据，因此CPU上的任何线程都能读取到这些数据的最新版本。(可见性保证)</p><p>单例模式中，DCL双锁就使用了volatile防止多线程下指令被重排。</p><h5 id="volatile的使用方式"><a href="#volatile的使用方式" class="headerlink" title="volatile的使用方式"></a>volatile的使用方式</h5><p>（不做具体介绍）</p><h3 id="为什么volatile不保证原子性？"><a href="#为什么volatile不保证原子性？" class="headerlink" title="为什么volatile不保证原子性？"></a>为什么volatile不保证原子性？</h3><h2 id="CAS底层实现原理"><a href="#CAS底层实现原理" class="headerlink" title="CAS底层实现原理"></a>CAS底层实现原理</h2><p>关键词：unsafe</p><p>在volatile中，因为不保证原子性，所以在多线程下是不安全的，需要通过CAS实现原子性。</p><p><strong>CAS：Compare and swap，比较并交换。</strong></p><p>第一步，在线程从主存读取一个值 V=5 后，会暂存这个 V 为 A，称为旧的预期值，再将 A 进行修改，假设将 A + 1，这时候使用 B = A + 1进行修改，B称为更新值。</p><p>第二步将 B 这个值赋值给主存的V时，会先进行比较，如果主存中的这个V还==旧预期值A，那么说明这个V是没有被操作过的，那么就可以进行数值的更新 V=B；但是如果此时 V ≠ A，说明这个值已经被修改了，那么线程将会返回，重新执行 V+1的操作，直到这个过程成功。</p><p>这就是CAS的基本实现过程。</p><h3 id="CAS源码实现"><a href="#CAS源码实现" class="headerlink" title="CAS源码实现"></a>CAS源码实现</h3><p>为什么CAS能实现原子性？靠的是底层的Unsafe类。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-keyword">this</span>, valueOffset, <span class="hljs-number">1</span>);&#125;</code></pre><p>因为Java无法和操作系统底层进行交互，需要通过本地方法（native）来访问。Unsafe存在于sum.misc包中，其内部方法可以直接操作特定内存的数据，像C的指针一样直接操作内存。</p><p>注：Unsafe中所以方法都是native修饰的，也就是说Unsafe类中的方法都调用操作系统的底层资源执行相应任务。</p><p>变量<strong>valueOffset</strong>，表示该变量在内存中的偏移地址</p><p><strong>CAS的功能判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。</strong></p><p>同时，因为比较并交换是系统原语，所以不会造成数据不一致的现象。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4)</span> </span>&#123;    <span class="hljs-keyword">int</span> var5;    <span class="hljs-keyword">do</span> &#123;        var5 = <span class="hljs-keyword">this</span>.getIntVolatile(var1, var2);    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));    <span class="hljs-keyword">return</span> var5;&#125;</code></pre><h3 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h3><ul><li>如果一直不成功，会给CPU带来很大开销；</li><li>只能保证一个变量的原子性操作；</li><li>会引发BAB问题。</li></ul><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>此时：主存中值为A，线程1和线程2取出A，线程2将A改为B并写回主存，然后又将B改为A写回主存，主存中的值由A-&gt;B-&gt;A，改变了两次，之后才线程1修改了A，将值传回主存，发现值没变，成功写入。</p><p>尽管线程1操作成功，但这个过程也是存在问题的。</p><h4 id="如何解决ABA问题？"><a href="#如何解决ABA问题？" class="headerlink" title="如何解决ABA问题？"></a>如何解决ABA问题？</h4><p>带时间戳的原子引用</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java单例</title>
    <link href="/posts/java-singleton/"/>
    <url>/posts/java-singleton/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>单例设计模式，即某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式。</p><p>1、单例类只能有一个实例。</p><p>2、单例类必须自己创建自己的唯一实例。</p><p>3、单例类必须给所有其他对象提供这一实例。</p><p><strong>优点：</strong></p><p>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。</p><p>2、避免对资源的多重占用。</p><p><strong>缺点：</strong></p><p>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p><strong>使用场景：</strong></p><p>1、要求生产唯一序列号。</p><p>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</p><p>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p><h3 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h3><p>创建一个Singleton类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo1</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建实例</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo1 instance = <span class="hljs-keyword">new</span> SingletonDemo1();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造方法私有化，这样该类就不会被实例化</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo1</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 返回实例，获取唯一可用对象</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> SingletonDemo1 instance</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo1 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> instance;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"Hello SingletonDemo1 !"</span>);    &#125;&#125;</code></pre><h3 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h3><p>从SingletonDemo1中获取唯一对象</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonMainDemo1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SingletonDemo1 instance = SingletonDemo1.getInstance();                instance.sayHello();    &#125;&#125;</code></pre><h3 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h3><p>控制台输出</p><pre><code class="hljs erlang-repl">Hello SingletonDemo1 !</code></pre><hr><h2 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h2><h3 id="1、懒汉式，线程不安全"><a href="#1、懒汉式，线程不安全" class="headerlink" title="1、懒汉式，线程不安全"></a>1、懒汉式，线程不安全</h3><p>是否 Lazy 初始化：是</p><p>是否多线程安全：否</p><p>实现难度：易</p><p>描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</p><p>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;          <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;          <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;              instance = <span class="hljs-keyword">new</span> Singleton();          &#125;          <span class="hljs-keyword">return</span> instance;      &#125;  &#125;</code></pre><p><strong>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。</strong></p><h3 id="2、懒汉式，线程安全"><a href="#2、懒汉式，线程安全" class="headerlink" title="2、懒汉式，线程安全"></a>2、懒汉式，线程安全</h3><p>是否 Lazy 初始化：是</p><p>是否多线程安全：是</p><p>实现难度：易</p><p>描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。</p><p>优点：第一次调用才初始化，避免内存浪费。</p><p>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;          <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;          <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;    &#125;          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;              instance = <span class="hljs-keyword">new</span> Singleton();          &#125;          <span class="hljs-keyword">return</span> instance;      &#125;  &#125;</code></pre><h3 id="3、饿汉式"><a href="#3、饿汉式" class="headerlink" title="3、饿汉式"></a>3、饿汉式</h3><p>是否 Lazy 初始化：否</p><p>是否多线程安全：是</p><p>实现难度：易</p><p>描述：这种方式比较常用，但容易产生垃圾对象。</p><p>优点：没有加锁，执行效率会提高。</p><p>缺点：类加载时就初始化，浪费内存。</p><p>它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;          <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();          <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;    &#125;          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">return</span> instance;      &#125;  &#125;</code></pre><h3 id="4、双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#4、双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="4、双检锁/双重校验锁（DCL，即 double-checked locking）"></a>4、双检锁/双重校验锁（DCL，即 double-checked locking）</h3><p>JDK 版本：JDK1.5 起</p><p>是否 Lazy 初始化：是</p><p>是否多线程安全：是</p><p>实现难度：较复杂</p><p>描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p><p>getInstance() 的性能对应用程序很关键。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;          <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton singleton;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;    &#125;          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;              <span class="hljs-keyword">synchronized</span> (Singleton<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;                  <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;                      singleton = <span class="hljs-keyword">new</span> Singleton();                  &#125;           &#125;      &#125;      <span class="hljs-keyword">return</span> singleton;      &#125; &#125;</code></pre><h3 id="5、登记式-静态内部类"><a href="#5、登记式-静态内部类" class="headerlink" title="5、登记式/静态内部类"></a>5、登记式/静态内部类</h3><p>是否 Lazy 初始化：是</p><p>是否多线程安全：是</p><p>实现难度：一般</p><p>描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p><p>这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。</p><p>因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;          <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();      &#125;          <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;    &#125;          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;      &#125;  &#125;</code></pre><h3 id="6、枚举"><a href="#6、枚举" class="headerlink" title="6、枚举"></a>6、枚举</h3><p>JDK 版本：JDK1.5 起</p><p>是否 Lazy 初始化：否</p><p>是否多线程安全：是</p><p>实现难度：易</p><p>描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</p><p>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 Enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。</p><p>不能通过 reflection attack 来调用私有构造方法。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Singleton &#123;        INSTANCE;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whateverMethod</span><span class="hljs-params">()</span> </span>&#123;     &#125;  &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap小结</title>
    <link href="/posts/HashMap/"/>
    <url>/posts/HashMap/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap小结"><a href="#HashMap小结" class="headerlink" title="HashMap小结"></a>HashMap小结</h1><ol><li>HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，具有自动扩容机制。且key-value可为null。</li><li>HashMap是线程不安全的。</li><li>HashMap 实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆。</li><li>在jdk1.8之前，HashMap采用<strong>数组+链表</strong>的储存方式。从jdk1.8开始，HashMap采用<strong>数组+链表/红黑树</strong>的储存方式。在阈值大于8且数组长度大于64时，链表会转换为红黑树的形式，以此提高HashMap的搜索效率。</li><li>当链表长度&gt;64以及链表长度&gt;8时，链表将转化为红黑树。当红黑树结点小于6时，再转换为链表。</li></ol><h2 id="1、HashMap的储存过程"><a href="#1、HashMap的储存过程" class="headerlink" title="1、HashMap的储存过程"></a>1、HashMap的储存过程</h2><p>首先来看一下HashMap的储存过程。</p><pre><code class="hljs java">HashMap&lt;String, String&gt; hashMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();hashMap.put(<span class="hljs-string">"Aa"</span>, <span class="hljs-string">"19"</span>);hashMap.put(<span class="hljs-string">"Cc"</span>, <span class="hljs-string">"17"</span>);hashMap.put(<span class="hljs-string">"BB"</span>, <span class="hljs-string">"20"</span>);hashMap.put(<span class="hljs-string">"Aa"</span>, <span class="hljs-string">"30"</span>);</code></pre><p><img src="https://img.neoniou.com/md/mianshi/image-20200318164927987.png" srcset="/img/loading.gif" alt="image-20200318164927987"></p><p>整个储存过程如下：</p><ol><li>开辟数组空间（默认16）</li><li>通过位运算计算”Aa”的Hash值及对应的索引，存储Aa-19</li><li>同上，存储Cc-17</li><li>当存储BB时，计算发现索引已经储存了键值对，发生Hash碰撞，再调用euqals方法，计算发现不相等，所以便通过链表储存BB-20</li><li>最后Aa-20，计算HashCode以及euqals都相同，则覆盖先前的值。</li></ol><h4 id="问题1：HashMap底层通过什么方式计算Hash值？还有哪些方法可以用于计算Hash值？"><a href="#问题1：HashMap底层通过什么方式计算Hash值？还有哪些方法可以用于计算Hash值？" class="headerlink" title="问题1：HashMap底层通过什么方式计算Hash值？还有哪些方法可以用于计算Hash值？"></a>问题1：HashMap底层通过什么方式计算Hash值？还有哪些方法可以用于计算Hash值？</h4><p>HashMap底层采用位运算计算，还可以通过伪随机数和取余进行计算。（取余在计算机底层效率很低，所以不使用）</p><h4 id="问题2：什么是Hash碰撞，如何解决？"><a href="#问题2：什么是Hash碰撞，如何解决？" class="headerlink" title="问题2：什么是Hash碰撞，如何解决？"></a>问题2：什么是Hash碰撞，如何解决？</h4><p>不同的键计算Hash值索引相同即会产生Hash碰撞，通过链表+红黑树的方法解决。</p><h2 id="2、HashMap的成员变量"><a href="#2、HashMap的成员变量" class="headerlink" title="2、HashMap的成员变量"></a>2、HashMap的成员变量</h2><h3 id="2-1、默认容量"><a href="#2-1、默认容量" class="headerlink" title="2.1、默认容量"></a>2.1、默认容量</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * The default initial capacity - MUST be a power of two.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span></code></pre><p>HashMap默认容量为16，且容量必须是2的n次幂。即使赋值不是2的n次幂，在底层也会转换为2的n次幂。</p><p><strong>举个栗子</strong>：</p><pre><code class="hljs java">HashMap&lt;String, String&gt; hashMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">10</span>);</code></pre><p>在底层10会变为比它大的最小的2的n次幂：10-&gt;16。以此类推7-&gt;8。</p><h4 id="问题3：为什么HashMap容量必须是2的n次幂？"><a href="#问题3：为什么HashMap容量必须是2的n次幂？" class="headerlink" title="问题3：为什么HashMap容量必须是2的n次幂？"></a>问题3：为什么HashMap容量必须是2的n次幂？</h4><p>为了减少Hash碰撞。</p><p>HashMap采用位运算：&gt;&gt;&gt; ^ &amp;计算Hash值。这个算法本质就是取模，hash%length，源码中进行了优化，使用hash&amp;(length-1)进行计算，而hash%length等于hash&amp;(length-1)的前提是数组长度为2的n次幂。</p><p><strong>举个栗子</strong>：</p><hr><p>数组长度为8</p><p>hash值：        3    00000011</p><p>length-1:         7    00000111，位运算结果：00000011，即索引为 3</p><p>hash值：        2    00000010</p><p>length-1:         7    00000110，位运算结果：00000011，即索引为 2</p><p>不会产生hash碰撞</p><hr><p>数组长度为9</p><p>hash值：        3    00000011</p><p>length-1:         8    00001000，位运算结果：00000000，即索引为 0</p><p>hash值：        2    00000010</p><p>length-1:         8    00001000，位运算结果：00000000，即索引为 0</p><p>产生hash碰撞</p><h3 id="2-2、负载因子"><a href="#2-2、负载因子" class="headerlink" title="2.2、负载因子"></a>2.2、负载因子</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * The load factor used when none specified in constructor.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;</code></pre><p>HashMap负载因子为0.75</p><p><strong>什么是负载因子？</strong>HashMap默认容量为16，当储存达到16*0.75=12时，便会执行扩容操作</p><p>threshold = capacity（默认长度16） * loadFactory（默认负载因子0.75）。这个值是是当前已经占用的数组长度的最大值，当size &gt;= threshold时，便会执行扩容。</p><h4 id="问题4：为什么负载因子设置为0-75？"><a href="#问题4：为什么负载因子设置为0-75？" class="headerlink" title="问题4：为什么负载因子设置为0.75？"></a>问题4：为什么负载因子设置为0.75？</h4><p>如果负载因子过小，则数组利用率会降低，加载因子过大，链表数量又会过多。所以兼顾利用率和链表长度，0.75是一个衡量后比较平衡的值。</p><h3 id="2-3、红黑树链表转换"><a href="#2-3、红黑树链表转换" class="headerlink" title="2.3、红黑树链表转换"></a>2.3、红黑树链表转换</h3><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;</code></pre><p>链表长度为8时：链表-&gt;红黑树，红黑树结点减少到6：红黑树-&gt;链表。</p><h4 id="问题5：为什么链表长度为8时转换为红黑树？"><a href="#问题5：为什么链表长度为8时转换为红黑树？" class="headerlink" title="问题5：为什么链表长度为8时转换为红黑树？"></a>问题5：为什么链表长度为8时转换为红黑树？</h4><p>根据泊松分布，HashMap中链表长度从0-&gt;8的概率是：</p><pre><code class="hljs angelscript"><span class="hljs-number">0</span>:    <span class="hljs-number">0.60653066</span><span class="hljs-number">1</span>:    <span class="hljs-number">0.30326533</span><span class="hljs-number">2</span>:    <span class="hljs-number">0.07581633</span><span class="hljs-number">3</span>:    <span class="hljs-number">0.01263606</span><span class="hljs-number">4</span>:    <span class="hljs-number">0.00157952</span><span class="hljs-number">5</span>:    <span class="hljs-number">0.00015795</span><span class="hljs-number">6</span>:    <span class="hljs-number">0.00001316</span><span class="hljs-number">7</span>:    <span class="hljs-number">0.00000094</span><span class="hljs-number">8</span>:    <span class="hljs-number">0.00000006</span></code></pre><p>因为红黑树占用的内存空间是链表的两倍，链表长度达到8已经是很小的概率，从而为了增加查找速度，才转换为红黑树。</p><p>红黑树平均查找复杂度是Log(n)，如果长度为8，Log(8)=3，链表的平均查找复杂度是n/2，长度为8时，8/2=4；这才有转换为红黑树的必要。</p><h2 id="2、HashMap的成员方法"><a href="#2、HashMap的成员方法" class="headerlink" title="2、HashMap的成员方法"></a>2、HashMap的成员方法</h2><h3 id="2-1-put方法"><a href="#2-1-put方法" class="headerlink" title="2.1 put方法"></a>2.1 put方法</h3><p>put方法步骤分为以下几步：</p><ol><li><p>首先通过hash值计算key应该映射到哪个索引；</p></li><li><p>如果索引没有hash碰撞，那么直接插入key-value；</p></li><li><p>如果出现碰撞，则需要进行处理：</p><p>a)已经使用红黑树，那么使用红黑树方法插入；</p><p>b)反之则使用链表插入，若达到临界值则转换为红黑树；</p></li><li><p>如果存在重复的key，那么则覆盖value；</p></li><li><p>如果size &gt;= threshold，则执行扩容操作。</p></li></ol><h2 id="3、一些问题"><a href="#3、一些问题" class="headerlink" title="3、一些问题"></a>3、一些问题</h2><h4 id="问题6：HashMap和HashTable的区别"><a href="#问题6：HashMap和HashTable的区别" class="headerlink" title="问题6：HashMap和HashTable的区别"></a>问题6：HashMap和HashTable的区别</h4><ol><li><p>继承父类不同；</p></li><li><p>线程安全性不同，HashMap线程不安全，HashTable线程安全；</p></li><li><p>contains方法有区别，HashMap去掉了contains方法，改为containsKey和containsValue；</p></li><li><p>在HashMap中，key-value都支持null值，HashTable中则不支持；</p><pre><code class="hljs java"><span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);</code></pre><p>HashMap通过将null值的key转换为0从而达到储存null值的key-value，而HashTable中则没有这个转换过程。</p></li><li><p>hash值不同。HashMap会重新计算hash值，HashTable则直接调用hashCode()方法；</p></li></ol><h4 id="问题7：HashMap如何实现线程安全？"><a href="#问题7：HashMap如何实现线程安全？" class="headerlink" title="问题7：HashMap如何实现线程安全？"></a>问题7：HashMap如何实现线程安全？</h4><ol><li>使用ConcurrentHashMap</li><li>使用synchronizedMap()方法包装 HashMap，得到线程安全的Map，并在此Map上进行操作。</li></ol>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Java+阿里云oss搭建图床 后台</title>
    <link href="/posts/java-oss-img/"/>
    <url>/posts/java-oss-img/</url>
    
    <content type="html"><![CDATA[<hr><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> neo.zzj</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImgService</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Allow upload type (image)</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; ALLOW_TYPE = Arrays.asList(<span class="hljs-string">"image/jpeg"</span>, <span class="hljs-string">"image/png"</span>, <span class="hljs-string">"image/bmp"</span>);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * oss information</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String endpoint;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String accessKeyId;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String accessKeySecret;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String bucketName;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String key;    <span class="hljs-keyword">static</span> &#123;        Properties props = <span class="hljs-keyword">new</span> Properties();        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(<span class="hljs-string">"oss.properties"</span>);        <span class="hljs-keyword">try</span> &#123;            props.load(is);            endpoint = props.getProperty(<span class="hljs-string">"endpoint"</span>);            accessKeyId = props.getProperty(<span class="hljs-string">"accessKeyId"</span>);            accessKeySecret = props.getProperty(<span class="hljs-string">"accessKeySecret"</span>);            bucketName = props.getProperty(<span class="hljs-string">"bucketName"</span>);            key = props.getProperty(<span class="hljs-string">"key"</span>);        &#125; <span class="hljs-keyword">catch</span> (                IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Upload img to aliyun oss</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file Image</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Img url</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">uploadImg</span><span class="hljs-params">(MultipartFile file)</span> </span>&#123;        <span class="hljs-comment">// Check file</span>        checkFile(file);        OSS ossClient = <span class="hljs-keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);        InputStream inputStream = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            String fileName = file.getOriginalFilename();            String name = fileName.substring(<span class="hljs-number">0</span>, fileName.lastIndexOf(<span class="hljs-string">"."</span>));            String prefix = fileName.substring(fileName.lastIndexOf(<span class="hljs-string">"."</span>));            <span class="hljs-comment">// Check img is exist and rename</span>            <span class="hljs-keyword">boolean</span> found;            <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                found = ossClient.doesObjectExist(bucketName, fileName);                <span class="hljs-keyword">if</span> (found) &#123;                    fileName = name + <span class="hljs-string">"("</span> + i + <span class="hljs-string">")"</span> + prefix;                    i += <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-comment">// Transfer type to file and upload</span>            <span class="hljs-keyword">final</span> File tempFile = File.createTempFile(UUID.randomUUID().toString().replace(<span class="hljs-string">"-"</span>,<span class="hljs-string">""</span>), prefix);            file.transferTo(tempFile);            inputStream = <span class="hljs-keyword">new</span> FileInputStream(tempFile);            ossClient.putObject(bucketName, fileName, inputStream);            <span class="hljs-comment">// Return img url</span>            <span class="hljs-keyword">return</span> <span class="hljs-string">"https://img.neoniou.com/"</span> + fileName;        &#125; <span class="hljs-keyword">catch</span> (OSSException oe) &#123;            System.out.println(<span class="hljs-string">"Caught an OSSException, which means your request made it to OSS, "</span>                    + <span class="hljs-string">"but was rejected with an error response for some reason."</span>);            System.out.println(<span class="hljs-string">"Error Message: "</span> + oe.getErrorMessage());            System.out.println(<span class="hljs-string">"Error Code:       "</span> + oe.getErrorCode());            System.out.println(<span class="hljs-string">"Request ID:      "</span> + oe.getRequestId());            System.out.println(<span class="hljs-string">"Host ID:           "</span> + oe.getHostId());        &#125; <span class="hljs-keyword">catch</span> (ClientException ce) &#123;            System.out.println(<span class="hljs-string">"Caught an ClientException, which means the client encountered "</span>                    + <span class="hljs-string">"a serious internal problem while trying to communicate with OSS, "</span>                    + <span class="hljs-string">"such as not being able to access the network."</span>);            System.out.println(<span class="hljs-string">"Error Message: "</span> + ce.getMessage());        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">assert</span> inputStream != <span class="hljs-keyword">null</span>;                inputStream.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;            ossClient.shutdown();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Check file type and content</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file MultipartFile file</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkFile</span><span class="hljs-params">(MultipartFile file)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// Check file type</span>            String contentType = file.getContentType();            <span class="hljs-keyword">if</span> (!ALLOW_TYPE.contains(contentType)) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NeoException(ExceptionEnum.INVALID_FILE_TYPE);            &#125;            <span class="hljs-comment">// Check file content</span>            BufferedImage image = ImageIO.read(file.getInputStream());            <span class="hljs-keyword">if</span> (image == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NeoException(ExceptionEnum.INVALID_FILE_TYPE);            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Delete temp file</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> files files</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteTempFile</span><span class="hljs-params">(File... files)</span> </span>&#123;        <span class="hljs-keyword">for</span> (File file : files) &#123;            <span class="hljs-keyword">if</span> (file.exists()) &#123;                file.delete();            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用NProgress、axios拦截器做一个网页加载进度条</title>
    <link href="/posts/nprogress/"/>
    <url>/posts/nprogress/</url>
    
    <content type="html"><![CDATA[<p>写前端的时候，想写一个顶部的进度条功能，然后就找到了NProgress。加上axios的拦截器，可以很方便的做一个顶部进度条的样式。</p><h3 id="1、安装-Nprogress"><a href="#1、安装-Nprogress" class="headerlink" title="1、安装 Nprogress"></a>1、安装 Nprogress</h3><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> nprogress <span class="hljs-comment">--save</span></code></pre><h3 id="2、创建aixos-js文件"><a href="#2、创建aixos-js文件" class="headerlink" title="2、创建aixos.js文件"></a>2、创建aixos.js文件</h3><p>写入</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span><span class="hljs-keyword">import</span> NProgress <span class="hljs-keyword">from</span> <span class="hljs-string">"nprogress"</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'nprogress/nprogress.css'</span>axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;        NProgress.inc();        <span class="hljs-keyword">return</span> config;    &#125;, error =&gt; &#123;        NProgress.done();        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error)    &#125;)axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;        NProgress.done();        <span class="hljs-keyword">return</span> res;    &#125;, error =&gt; &#123;        NProgress.done();        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error)    &#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    NProgress&#125;</code></pre><h3 id="3、在main-js中引入"><a href="#3、在main-js中引入" class="headerlink" title="3、在main.js中引入"></a>3、在main.js中引入</h3><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">"./plugins/axios"</span>;...<span class="hljs-keyword">new</span> Vue(&#123;    ...    axios,    ...    render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App)&#125;).$mount(<span class="hljs-string">'#app'</span>)</code></pre><h3 id="4、修改样式"><a href="#4、修改样式" class="headerlink" title="4、修改样式"></a>4、修改样式</h3><p>如果需要修改进度条样式，可以把nprogress.css提取出来，然后引入：</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">'../../src/assets/css/nprogress.css'</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Axios</tag>
      
      <tag>NProgress</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Vue项目优化首页打开速度</title>
    <link href="/posts/fast-vue-index/"/>
    <url>/posts/fast-vue-index/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>最近部署了一个Vue项目，但在测试时发现打开首页后，会花费很久的时间去加载CSS和JS文件，打开需要10s+。 所以寻找了一些优化方法。</strong></p></blockquote><h3 id="一、Vue-router懒加载"><a href="#一、Vue-router懒加载" class="headerlink" title="一、Vue router懒加载"></a>一、Vue router懒加载</h3><p>懒加载前：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> Login from <span class="hljs-string">"../components/Login.vue"</span><span class="hljs-keyword">const</span> routes = [  &#123; path: <span class="hljs-string">'/login'</span>, component: Login, meta: &#123; title: <span class="hljs-string">'登录'</span> &#125;,&#125;]</code></pre><p>修改为懒加载后：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Login = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../components/Login.vue'</span>)<span class="hljs-keyword">const</span> routes = [  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/login'</span>, <span class="hljs-attr">component</span>: Login, <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'登录'</span> &#125;,&#125;]</code></pre><p>这种方法虽然可以把CSS和JS文件打包为很多个，但是vender文件依然很大。 </p><p>懒加载方法比较适用于部分非首页页面过大的问题。</p><h3 id="二、组件CDN加载"><a href="#二、组件CDN加载" class="headerlink" title="二、组件CDN加载"></a>二、组件CDN加载</h3><p>我的项目使用了Vue + element等。 如果把这些组件通过CDN加载，而不是打包为项目的文件，将会大大减小vender文件大小。</p><h4 id="1、在vue-config-js中设置"><a href="#1、在vue-config-js中设置" class="headerlink" title="1、在vue.config.js中设置"></a>1、在vue.config.js中设置</h4><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  <span class="hljs-comment">/* 设置不打包 */</span>  configureWebpack: &#123;    externals: &#123;      <span class="hljs-string">'vue'</span>: <span class="hljs-string">'Vue'</span>,      <span class="hljs-string">'vue-router'</span>: <span class="hljs-string">'VueRouter'</span>,      <span class="hljs-string">'element-ui'</span>: <span class="hljs-string">'ELEMENT'</span>    &#125;  &#125;&#125;</code></pre><p>注：如果是其他组件，该如何设置？</p><p>例：</p><pre><code class="hljs clean"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span></code></pre><p>则写法则是：</p><pre><code class="hljs coffeescript">//<span class="hljs-keyword">from</span>的部分在前，<span class="hljs-keyword">import</span>的部分在后<span class="hljs-string">'vue'</span>: <span class="hljs-string">'Vue'</span></code></pre><h4 id="2、在main-js中设置"><a href="#2、在main-js中设置" class="headerlink" title="2、在main.js中设置"></a>2、在main.js中设置</h4><p>在main.js中将CSS文件注释掉，让他们通过CDN加载。</p><pre><code class="hljs js"><span class="hljs-comment">//import 'view-design/dist/styles/iview.css';</span><span class="hljs-comment">//import 'element-ui/lib/theme-chalk/index.css'</span></code></pre><h4 id="3、在index-html中引入CDN"><a href="#3、在index-html中引入CDN" class="headerlink" title="3、在index.html中引入CDN"></a>3、在index.html中引入CDN</h4><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://unpkg.com/element-ui@2.13.0/lib/theme-chalk/index.css"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://unpkg.com/iview@3.5.4/dist/styles/iview.css"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/vue@2.6.10/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/vue-router@3.1.3/dist/vue-router.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/element-ui@2.13.0/lib/index.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h3 id="三、优化效果"><a href="#三、优化效果" class="headerlink" title="三、优化效果"></a>三、优化效果</h3><p>在结束优化后，vender文件大小都缩小到了80kb，其中CSS文件大小都只有几kb。 根据加载的waterfall，加载时间在2s左右，加载瓶颈在CDN的速度，比起之前的10s+已经有了很大的优化。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java TCP文件上传小程序</title>
    <link href="/posts/java-tcp-program/"/>
    <url>/posts/java-tcp-program/</url>
    
    <content type="html"><![CDATA[<p>一个基于TCP的简单的文件上传程序</p><hr><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.net.*;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//文件路径和文件</span>        String filePath;        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);        System.out.println(<span class="hljs-string">"输入要上传的文件地址："</span>);        filePath = sc.nextLine();        <span class="hljs-comment">//创建本地字节输入流，读取文件</span>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(filePath);        <span class="hljs-comment">//服务器地址及端口</span>        Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">7222</span>);        <span class="hljs-comment">//创建网络字节输出流，向服务器传递文件</span>        OutputStream os = socket.getOutputStream();        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>((len = fis.read(bytes)) != -<span class="hljs-number">1</span>) &#123;            os.write(bytes, <span class="hljs-number">0</span>, len);        &#125;        <span class="hljs-comment">//shutdown结束上传</span>        socket.shutdownOutput();        <span class="hljs-comment">//创建网络字节输入流，读取服务器传递的信息</span>        InputStream is = socket.getInputStream();        <span class="hljs-keyword">while</span>((len = is.read(bytes)) != -<span class="hljs-number">1</span>) &#123;            System.out.println(<span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, len));        &#125;        <span class="hljs-comment">//关闭</span>        fis.close();        socket.close();    &#125;&#125;</code></pre><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.net.*;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//创建服务器端口</span>        ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">7222</span>);        <span class="hljs-comment">//使用while使服务器保持监听状态</span>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-comment">//接受客户端请求</span>            Socket socket = server.accept();            <span class="hljs-comment">//使用多线程上传</span>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">//创建网络字节输入流，收取客户端上传的文件</span>                        InputStream is = socket.getInputStream();                        <span class="hljs-comment">//判断文件夹是否存在，不存在则创建文件夹</span>                        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\UpdatePath"</span>);                        <span class="hljs-keyword">if</span> (!file.exists()) &#123;                            file.mkdirs();                        &#125;                        <span class="hljs-comment">//创建上传文件的命名规则</span>                        <span class="hljs-comment">//int nums = 0;</span>                        String fileName = <span class="hljs-string">"File"</span> + System.currentTimeMillis() + <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">99</span>) + <span class="hljs-string">".zip"</span>;                        <span class="hljs-comment">//nums++;</span>                        <span class="hljs-comment">//创建本地字节输出流，向硬盘中保存文件</span>                        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(file + <span class="hljs-string">"\\"</span> + fileName);                        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];                        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;                        <span class="hljs-keyword">while</span> ((len = is.read(bytes)) != -<span class="hljs-number">1</span>) &#123;                            fos.write(bytes, <span class="hljs-number">0</span>, len);                        &#125;                        <span class="hljs-comment">//创建网络字节输出流，向客户端发送已经上传完成的信息</span>                        OutputStream os = socket.getOutputStream();                        os.write(<span class="hljs-string">"Update complete! =w= ~"</span>.getBytes());                        <span class="hljs-comment">//关闭</span>                        fos.close();                        socket.close();                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                        System.out.println(e);                    &#125;                &#125;            &#125;).start();        &#125;        <span class="hljs-comment">//server.close();</span>    &#125;&#125;</code></pre><hr><p>以后有空可以再完善一下，识别上传文件的文件类型和文件名</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“过完这个冬季，你是否一如往昔”</title>
    <link href="/posts/guo-wan-zhe-ge-dong-ji/"/>
    <url>/posts/guo-wan-zhe-ge-dong-ji/</url>
    
    <content type="html"><![CDATA[<blockquote><p>以前拍照，拍完过后都会直接p完发出来，特别急。现在就喜欢憋一憋了，一些好看的照片，会在硬盘上存着，等着哪天心情愉悦或是沮丧的时候，再把它们拿出来，发个朋友圈，微博。</p></blockquote><p>这是一组冬天的胶片，重庆的冬天，阳光和蓝天是特别珍贵的东西。所以我也按下了快门，把这些景色存在了胶片里</p><hr><img src="https://s2.ax1x.com/2020/03/10/8CL1xI.jpg" srcset="/img/loading.gif" /><img src="https://s2.ax1x.com/2020/03/10/8CLUIg.jpg" srcset="/img/loading.gif"/><img src="https://s2.ax1x.com/2020/03/10/8CL0Rs.jpg" srcset="/img/loading.gif" /><img src="https://s2.ax1x.com/2020/03/10/8CLss0.jpg" srcset="/img/loading.gif" /><img src="https://s2.ax1x.com/2020/03/10/8CL2oF.jpg" srcset="/img/loading.gif" /><img src="https://s2.ax1x.com/2020/03/10/8CLfJJ.jpg" srcset="/img/loading.gif"/>]]></content>
    
    
    <categories>
      
      <category>摄影</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
